CCS PCH C Compiler, Version 5.008, 5967               10-mai-20 22:21

               Filename:   C:\Users\obi-o\Documents\2TL1\Projet_Elec_grp4\C\main.lst

               ROM used:   1408 bytes (4%)
                           Largest free fragment is 31356
               RAM used:   46 (3%) at main() level
                           57 (4%) worst case
               Stack used: 2 locations (1 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   036E
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.5
004A:  GOTO   0054
004E:  BTFSC  F9E.5
0050:  GOTO   0096
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
.................... #include <main.h> 
.................... #include <18F458.h> 
.................... //////// Standard Header file for the PIC18F458 device //////////////// 
.................... #device PIC18F458 
*
00CA:  MOVLW  8E
00CC:  MOVWF  00
00CE:  MOVFF  2D,01
00D2:  MOVFF  2C,02
00D6:  CLRF   03
00D8:  MOVF   01,F
00DA:  BNZ   00EE
00DC:  MOVFF  02,01
00E0:  CLRF   02
00E2:  MOVLW  08
00E4:  SUBWF  00,F
00E6:  MOVF   01,F
00E8:  BNZ   00EE
00EA:  CLRF   00
00EC:  BRA    00FE
00EE:  BCF    FD8.0
00F0:  BTFSC  01.7
00F2:  BRA    00FC
00F4:  RLCF   02,F
00F6:  RLCF   01,F
00F8:  DECF   00,F
00FA:  BRA    00EE
00FC:  BCF    01.7
00FE:  GOTO   03E8 (RETURN)
0102:  MOVF   2C,W
0104:  BTFSC  FD8.2
0106:  BRA    01EA
0108:  MOVWF  00
010A:  MOVF   30,W
010C:  BTFSC  FD8.2
010E:  BRA    01EA
0110:  ADDWF  00,F
0112:  BNC   011C
0114:  MOVLW  81
0116:  ADDWF  00,F
0118:  BC    01EA
011A:  BRA    0124
011C:  MOVLW  7F
011E:  SUBWF  00,F
0120:  BNC   01EA
0122:  BZ    01EA
0124:  MOVFF  2D,34
0128:  MOVF   31,W
012A:  XORWF  34,F
012C:  BSF    2D.7
012E:  BSF    31.7
0130:  MOVF   2F,W
0132:  MULWF  33
0134:  MOVFF  FF4,36
0138:  MOVF   2E,W
013A:  MULWF  32
013C:  MOVFF  FF4,03
0140:  MOVFF  FF3,35
0144:  MULWF  33
0146:  MOVF   FF3,W
0148:  ADDWF  36,F
014A:  MOVF   FF4,W
014C:  ADDWFC 35,F
014E:  MOVLW  00
0150:  ADDWFC 03,F
0152:  MOVF   2F,W
0154:  MULWF  32
0156:  MOVF   FF3,W
0158:  ADDWF  36,F
015A:  MOVF   FF4,W
015C:  ADDWFC 35,F
015E:  MOVLW  00
0160:  CLRF   02
0162:  ADDWFC 03,F
0164:  ADDWFC 02,F
0166:  MOVF   2D,W
0168:  MULWF  33
016A:  MOVF   FF3,W
016C:  ADDWF  35,F
016E:  MOVF   FF4,W
0170:  ADDWFC 03,F
0172:  MOVLW  00
0174:  ADDWFC 02,F
0176:  MOVF   2D,W
0178:  MULWF  32
017A:  MOVF   FF3,W
017C:  ADDWF  03,F
017E:  MOVF   FF4,W
0180:  ADDWFC 02,F
0182:  MOVLW  00
0184:  CLRF   01
0186:  ADDWFC 01,F
0188:  MOVF   2F,W
018A:  MULWF  31
018C:  MOVF   FF3,W
018E:  ADDWF  35,F
0190:  MOVF   FF4,W
0192:  ADDWFC 03,F
0194:  MOVLW  00
0196:  ADDWFC 02,F
0198:  ADDWFC 01,F
019A:  MOVF   2E,W
019C:  MULWF  31
019E:  MOVF   FF3,W
01A0:  ADDWF  03,F
01A2:  MOVF   FF4,W
01A4:  ADDWFC 02,F
01A6:  MOVLW  00
01A8:  ADDWFC 01,F
01AA:  MOVF   2D,W
01AC:  MULWF  31
01AE:  MOVF   FF3,W
01B0:  ADDWF  02,F
01B2:  MOVF   FF4,W
01B4:  ADDWFC 01,F
01B6:  INCF   00,F
01B8:  BTFSC  01.7
01BA:  BRA    01C6
01BC:  RLCF   35,F
01BE:  RLCF   03,F
01C0:  RLCF   02,F
01C2:  RLCF   01,F
01C4:  DECF   00,F
01C6:  MOVLW  00
01C8:  BTFSS  35.7
01CA:  BRA    01E0
01CC:  INCF   03,F
01CE:  ADDWFC 02,F
01D0:  ADDWFC 01,F
01D2:  MOVF   01,W
01D4:  BNZ   01E0
01D6:  MOVF   02,W
01D8:  BNZ   01E0
01DA:  MOVF   03,W
01DC:  BNZ   01E0
01DE:  INCF   00,F
01E0:  BTFSC  34.7
01E2:  BSF    01.7
01E4:  BTFSS  34.7
01E6:  BCF    01.7
01E8:  BRA    01F2
01EA:  CLRF   00
01EC:  CLRF   01
01EE:  CLRF   02
01F0:  CLRF   03
01F2:  GOTO   040A (RETURN)
01F6:  MOVLW  8E
01F8:  MOVWF  00
01FA:  MOVF   2C,W
01FC:  SUBWF  00,F
01FE:  MOVFF  2D,02
0202:  MOVFF  2E,01
0206:  BSF    02.7
0208:  MOVF   00,F
020A:  BZ    021E
020C:  BCF    FD8.0
020E:  MOVF   02,F
0210:  BNZ   0216
0212:  MOVF   01,F
0214:  BZ    021E
0216:  RRCF   02,F
0218:  RRCF   01,F
021A:  DECFSZ 00,F
021C:  BRA    020C
021E:  BTFSS  2D.7
0220:  BRA    022C
0222:  COMF   01,F
0224:  COMF   02,F
0226:  INCF   01,F
0228:  BTFSC  FD8.2
022A:  INCF   02,F
022C:  GOTO   041C (RETURN)
0230:  MOVFF  FEA,34
0234:  MOVFF  FE9,33
0238:  BTFSS  2D.7
023A:  BRA    024C
023C:  BSF    33.7
023E:  BTFSS  33.4
0240:  INCF   33,F
0242:  COMF   2C,F
0244:  COMF   2D,F
0246:  INCF   2C,F
0248:  BTFSC  FD8.2
024A:  INCF   2D,F
024C:  SWAPF  2D,W
024E:  IORLW  F0
0250:  MOVWF  2F
0252:  ADDWF  2F,F
0254:  ADDLW  E2
0256:  MOVWF  30
0258:  ADDLW  32
025A:  MOVWF  32
025C:  MOVF   2D,W
025E:  ANDLW  0F
0260:  ADDWF  30,F
0262:  ADDWF  30,F
0264:  ADDWF  32,F
0266:  ADDLW  E9
0268:  MOVWF  31
026A:  ADDWF  31,F
026C:  ADDWF  31,F
026E:  SWAPF  2C,W
0270:  ANDLW  0F
0272:  ADDWF  31,F
0274:  ADDWF  32,F
0276:  RLCF   31,F
0278:  RLCF   32,F
027A:  COMF   32,F
027C:  RLCF   32,F
027E:  MOVF   2C,W
0280:  ANDLW  0F
0282:  ADDWF  32,F
0284:  RLCF   2F,F
0286:  MOVLW  07
0288:  MOVWF  2E
028A:  MOVLW  0A
028C:  DECF   31,F
028E:  ADDWF  32,F
0290:  BNC   028C
0292:  DECF   30,F
0294:  ADDWF  31,F
0296:  BNC   0292
0298:  DECF   2F,F
029A:  ADDWF  30,F
029C:  BNC   0298
029E:  DECF   2E,F
02A0:  ADDWF  2F,F
02A2:  BNC   029E
02A4:  CLRF   FEA
02A6:  MOVLW  2E
02A8:  MOVWF  FE9
02AA:  MOVLW  07
02AC:  ANDWF  33,W
02AE:  BCF    33.6
02B0:  DECF   FE9,F
02B2:  ANDWF  33,W
02B4:  BNZ   02C4
02B6:  BTFSC  33.4
02B8:  INCF   FE9,F
02BA:  BTFSC  33.4
02BC:  BRA    02C4
02BE:  MOVLW  20
02C0:  MOVWF  00
02C2:  BRA    02FC
02C4:  ADDWF  FE9,F
02C6:  MOVLW  32
02C8:  SUBWF  FE9,W
02CA:  BTFSC  FD8.2
02CC:  BSF    33.6
02CE:  MOVF   FEF,W
02D0:  MOVWF  00
02D2:  BNZ   02E4
02D4:  BTFSC  33.6
02D6:  BRA    02E4
02D8:  BTFSC  33.4
02DA:  BRA    0304
02DC:  BTFSC  33.3
02DE:  BRA    02E4
02E0:  MOVLW  20
02E2:  BRA    02FA
02E4:  BTFSS  33.7
02E6:  BRA    02F4
02E8:  MOVLW  2D
02EA:  MOVWF  00
02EC:  MOVF   FED,W
02EE:  BCF    33.6
02F0:  BCF    33.7
02F2:  BRA    02FC
02F4:  BSF    33.3
02F6:  BCF    33.4
02F8:  MOVLW  30
02FA:  ADDWF  00,F
02FC:  MOVF   00,W
02FE:  BTFSS  F9E.4
0300:  BRA    02FE
0302:  MOVWF  FAD
0304:  MOVF   FEE,W
0306:  BTFSS  33.6
0308:  BRA    02C6
030A:  GOTO   0432 (RETURN)
030E:  CLRF   01
0310:  CLRF   02
0312:  CLRF   00
0314:  CLRF   03
0316:  MOVF   31,W
0318:  BNZ   031E
031A:  MOVF   30,W
031C:  BZ    034E
031E:  MOVLW  10
0320:  MOVWF  32
0322:  BCF    FD8.0
0324:  RLCF   2E,F
0326:  RLCF   2F,F
0328:  RLCF   00,F
032A:  RLCF   03,F
032C:  MOVF   31,W
032E:  SUBWF  03,W
0330:  BNZ   0336
0332:  MOVF   30,W
0334:  SUBWF  00,W
0336:  BNC   0346
0338:  MOVF   30,W
033A:  SUBWF  00,F
033C:  BTFSS  FD8.0
033E:  DECF   03,F
0340:  MOVF   31,W
0342:  SUBWF  03,F
0344:  BSF    FD8.0
0346:  RLCF   01,F
0348:  RLCF   02,F
034A:  DECFSZ 32,F
034C:  BRA    0322
034E:  RETURN 0
0350:  MOVF   2E,W
0352:  MULWF  30
0354:  MOVFF  FF3,01
0358:  MOVFF  FF4,00
035C:  MULWF  31
035E:  MOVF   FF3,W
0360:  ADDWF  00,F
0362:  MOVF   2F,W
0364:  MULWF  30
0366:  MOVF   FF3,W
0368:  ADDWFC 00,W
036A:  MOVWF  02
036C:  RETURN 0
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal=20000000) 
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #fuses HS, NOPROTECT, NOLVP, NOWDT  
.................... #use rs232(baud=9600,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
.................... #byte PORTC = 0xF82 
....................  
.................... //Gestion communication port COM 
.................... char buffer[4];// valeurs de seuil 
.................... int toRead=0; // Flag pour actualisation du seuil 
.................... int compteur=0; // Nombre de caractère écrit 
.................... #int_RDA 
.................... void RDA_isr(void)  
.................... { 
....................    buffer[compteur]=getc(); 
*
0096:  CLRF   03
0098:  MOVF   1D,W
009A:  ADDLW  18
009C:  MOVWF  FE9
009E:  MOVLW  00
00A0:  ADDWFC 03,W
00A2:  MOVWF  FEA
00A4:  BTFSS  F9E.5
00A6:  BRA    00A4
00A8:  MOVFF  FAE,FEF
....................    if(buffer[0]=='!' && toRead==0){ 
00AC:  MOVF   18,W
00AE:  SUBLW  21
00B0:  BNZ   00C4
00B2:  MOVF   1C,F
00B4:  BNZ   00C4
....................       compteur++; 
00B6:  INCF   1D,F
....................       if(compteur>=4){ 
00B8:  MOVF   1D,W
00BA:  SUBLW  03
00BC:  BC    00C4
....................          compteur=0; 
00BE:  CLRF   1D
....................          toRead=1; 
00C0:  MOVLW  01
00C2:  MOVWF  1C
....................       } 
....................    }    
00C4:  BCF    F9E.5
00C6:  GOTO   0054
.................... } 
....................  
.................... void main() 
*
036E:  CLRF   FF8
0370:  BCF    FD0.7
0372:  BSF    07.7
0374:  MOVLW  81
0376:  MOVWF  FAF
0378:  MOVLW  A6
037A:  MOVWF  FAC
037C:  MOVLW  90
037E:  MOVWF  FAB
0380:  CLRF   1C
0382:  CLRF   1D
0384:  BSF    FC1.0
0386:  BSF    FC1.1
0388:  BSF    FC1.2
038A:  BCF    FC1.3
038C:  MOVLW  07
038E:  MOVWF  FB4
0390:  CLRF   16
0392:  CLRF   17
.................... { 
....................     
....................    int16 valeur; 
....................    int16 seuil; 
....................    long temps; 
....................    int gauche,droite; 
....................    int16 centaine,dizaine,unite; 
....................     
....................    set_tris_c(0b10000010); 
0394:  MOVLW  82
0396:  MOVWF  F94
....................     
....................    enable_interrupts(INT_RDA); 
0398:  BSF    F9D.5
....................    enable_interrupts(GLOBAL); 
039A:  MOVLW  C0
039C:  IORWF  FF2,F
....................    setup_timer_0(RTCC_INTERNAL); 
039E:  MOVLW  80
03A0:  MOVWF  FD5
....................    setup_low_volt_detect(FALSE); 
03A2:  CLRF   FD2
....................  
....................    while(TRUE) 
....................    { 
....................     
....................          //Initialisation 
....................          output_low(PIN_C0); 
03A4:  BCF    F94.0
03A6:  BCF    F8B.0
....................          delay_us(5); 
03A8:  MOVLW  07
03AA:  MOVWF  00
03AC:  DECFSZ 00,F
03AE:  BRA    03AC
03B0:  BRA    03B2
03B2:  NOP   
....................           
....................         //Démarrage 
....................         output_high(PIN_C0); 
03B4:  BCF    F94.0
03B6:  BSF    F8B.0
....................         delay_us(10); 
03B8:  MOVLW  10
03BA:  MOVWF  00
03BC:  DECFSZ 00,F
03BE:  BRA    03BC
03C0:  NOP   
....................         output_low(PIN_C0); 
03C2:  BCF    F94.0
03C4:  BCF    F8B.0
....................           
....................         //Mise en marche 
....................         while(!input(PIN_C1)) {} 
03C6:  BSF    F94.1
03C8:  BTFSS  F82.1
03CA:  BRA    03C6
....................         set_timer0(0); 
03CC:  CLRF   FD7
03CE:  CLRF   FD6
....................         while(input(PIN_C1)) {} 
03D0:  BSF    F94.1
03D2:  BTFSC  F82.1
03D4:  BRA    03D0
....................         temps = (long)get_timer0(); 
03D6:  MOVF   FD6,W
03D8:  MOVWF  22
03DA:  MOVFF  FD7,23
....................          
....................         //Calcul 
....................         valeur = (int16)temps*0.017;//En centimètres 
03DE:  MOVFF  23,2D
03E2:  MOVFF  22,2C
03E6:  BRA    00CA
03E8:  MOVFF  03,2F
03EC:  MOVFF  02,2E
03F0:  MOVFF  01,2D
03F4:  MOVFF  00,2C
03F8:  MOVLW  96
03FA:  MOVWF  33
03FC:  MOVLW  43
03FE:  MOVWF  32
0400:  MOVLW  0B
0402:  MOVWF  31
0404:  MOVLW  79
0406:  MOVWF  30
0408:  BRA    0102
040A:  MOVFF  03,2F
040E:  MOVFF  02,2E
0412:  MOVFF  01,2D
0416:  MOVFF  00,2C
041A:  BRA    01F6
041C:  MOVFF  02,1F
0420:  MOVFF  01,1E
....................         printf("%ld$",valeur); 
0424:  MOVLW  10
0426:  MOVWF  FE9
0428:  MOVFF  1F,2D
042C:  MOVFF  1E,2C
0430:  BRA    0230
0432:  MOVLW  24
0434:  BTFSS  F9E.4
0436:  BRA    0434
0438:  MOVWF  FAD
....................          
....................         //Affichage 
....................        if (valeur >= 1000) { 
043A:  MOVF   1F,W
043C:  SUBLW  02
043E:  BC    0454
0440:  XORLW  FF
0442:  BNZ   044A
0444:  MOVF   1E,W
0446:  SUBLW  E7
0448:  BC    0454
....................             gauche = 0; 
044A:  CLRF   24
....................             droite = 0; 
044C:  CLRF   25
....................             output_high(PIN_E0); 
044E:  BCF    F96.0
0450:  BSF    F8D.0
....................        } 
0452:  BRA    04E6
....................        else if (valeur >= 100) { 
0454:  MOVF   1F,F
0456:  BNZ   045E
0458:  MOVF   1E,W
045A:  SUBLW  63
045C:  BC    04A4
....................             gauche =(int) (valeur/100); 
045E:  MOVFF  1F,2F
0462:  MOVFF  1E,2E
0466:  CLRF   31
0468:  MOVLW  64
046A:  MOVWF  30
046C:  RCALL  030E
046E:  MOVFF  01,24
....................             droite =(int) ((valeur%100)/10); 
0472:  MOVFF  1F,2F
0476:  MOVFF  1E,2E
047A:  CLRF   31
047C:  MOVLW  64
047E:  MOVWF  30
0480:  RCALL  030E
0482:  MOVFF  00,2C
0486:  MOVFF  03,2D
048A:  MOVFF  03,2F
048E:  MOVFF  00,2E
0492:  CLRF   31
0494:  MOVLW  0A
0496:  MOVWF  30
0498:  RCALL  030E
049A:  MOVFF  01,25
....................             output_high(PIN_E0); 
049E:  BCF    F96.0
04A0:  BSF    F8D.0
....................          } 
04A2:  BRA    04E6
....................        else if (valeur >=10) { 
04A4:  MOVF   1F,F
04A6:  BNZ   04AE
04A8:  MOVF   1E,W
04AA:  SUBLW  09
04AC:  BC    04DC
....................             gauche = (int) (valeur/10); 
04AE:  MOVFF  1F,2F
04B2:  MOVFF  1E,2E
04B6:  CLRF   31
04B8:  MOVLW  0A
04BA:  MOVWF  30
04BC:  RCALL  030E
04BE:  MOVFF  01,24
....................             droite = (int) (valeur%10); 
04C2:  MOVFF  1F,2F
04C6:  MOVFF  1E,2E
04CA:  CLRF   31
04CC:  MOVLW  0A
04CE:  MOVWF  30
04D0:  RCALL  030E
04D2:  MOVFF  00,25
....................             output_low(PIN_E0); 
04D6:  BCF    F96.0
04D8:  BCF    F8D.0
....................        } 
04DA:  BRA    04E6
....................        else { 
....................             gauche = 0; 
04DC:  CLRF   24
....................             droite = (int) valeur; 
04DE:  MOVFF  1E,25
....................             output_low(PIN_E0); 
04E2:  BCF    F96.0
04E4:  BCF    F8D.0
....................        } 
....................        output_b(gauche+(droite<<4)); 
04E6:  SWAPF  25,W
04E8:  MOVWF  00
04EA:  MOVLW  F0
04EC:  ANDWF  00,F
04EE:  MOVF   00,W
04F0:  ADDWF  24,W
04F2:  CLRF   F93
04F4:  MOVWF  F8A
....................         
....................        //Calcul du seuil 
....................        if (toRead == 1) { 
04F6:  DECFSZ 1C,W
04F8:  BRA    0552
....................          centaine = buffer[1] - 48; 
04FA:  MOVLW  30
04FC:  SUBWF  19,W
04FE:  MOVWF  26
0500:  CLRF   27
....................          dizaine = buffer[2] - 48; 
0502:  MOVLW  30
0504:  SUBWF  1A,W
0506:  MOVWF  28
0508:  CLRF   29
....................          unite = buffer[3] - 48; 
050A:  MOVLW  30
050C:  SUBWF  1B,W
050E:  MOVWF  2A
0510:  CLRF   2B
....................          seuil = ((100*centaine)+(10*dizaine)+unite); 
0512:  CLRF   2F
0514:  MOVLW  64
0516:  MOVWF  2E
0518:  MOVFF  27,31
051C:  MOVFF  26,30
0520:  RCALL  0350
0522:  MOVFF  02,2D
0526:  MOVFF  01,2C
052A:  CLRF   2F
052C:  MOVLW  0A
052E:  MOVWF  2E
0530:  MOVFF  29,31
0534:  MOVFF  28,30
0538:  RCALL  0350
053A:  MOVF   01,W
053C:  ADDWF  2C,F
053E:  MOVF   02,W
0540:  ADDWFC 2D,F
0542:  MOVF   2A,W
0544:  ADDWF  2C,W
0546:  MOVWF  20
0548:  MOVF   2B,W
054A:  ADDWFC 2D,W
054C:  MOVWF  21
....................          toRead = 0; 
054E:  CLRF   1C
....................        } 
0550:  BRA    0560
....................        else { 
....................          if (seuil == NULL) { 
0552:  MOVF   20,F
0554:  BNZ   0560
0556:  MOVF   21,F
0558:  BNZ   0560
....................             seuil = 25; 
055A:  CLRF   21
055C:  MOVLW  19
055E:  MOVWF  20
....................          } 
....................        } 
....................         
....................        //Gestion led % seuil 
....................        if (valeur > seuil) { 
0560:  MOVF   21,W
0562:  SUBWF  1F,W
0564:  BNC   0578
0566:  BNZ   056E
0568:  MOVF   1E,W
056A:  SUBWF  20,W
056C:  BC    0578
....................             output_low(PIN_E2); 
056E:  BCF    F96.2
0570:  BCF    F8D.2
....................             output_toggle(PIN_E1); 
0572:  BCF    F96.1
0574:  BTG    F8D.1
....................        } 
0576:  BRA    0580
....................        else { 
....................             output_high(PIN_E2); 
0578:  BCF    F96.2
057A:  BSF    F8D.2
....................             output_low(PIN_E1); 
057C:  BCF    F96.1
057E:  BCF    F8D.1
....................        } 
0580:  BRA    03A4
....................   } 
.................... } 
....................                 
0582:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0C   PUT NOBROWNOUT BORV25 NOWDT WDT128
   Word  3: 0000  
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
